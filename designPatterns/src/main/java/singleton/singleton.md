1.单例模式目前有以下几种写法：
  1.1、饿汉模式
  1.2、懒汉模式
  1.3、注册式单例
  
2.各单例模式的优缺点：
  2.1、饿汉模式：类加载的时候立即初始化，优点是没有任何锁，线程安全，执行效率较高，在用户体验上来说，比懒汉式更好，缺点是不管用不用，都占着空间，若是
  一直不用，浪费了内存空间。
  2.2、懒汉模式：被外部类调用的时候才加载，优点是要用时才初始化，不会浪费系统内存，缺点是线程不安全，若是加锁解决线程安全问题，又会影响效率。可通过使用
  懒加载和静态内部类的方式解决线程安全、执行效率和内存空间利用率的问题（根据静态内部类在使用时才加载，且一定先加载完才使用的特性，很好的解决线程安全，执
  行效率，内存空间利用率的问题），代码如下：
  public class LazyInnerClassSingleton {
      /**
       * 私有化构造
       */
      private LazyInnerClassSingleton() {
          //调用内部类，构建一个实例，判断内部类的实例不为空，达到防止反射破坏单例的目的
          if(LazyLoader.LAZY!=null){
              throw new RuntimeException("不允许创建多个单例");
          }
      }
  
      /**
       *static关键字保证了单例对象的空间共享
       * final关键字保证了方法不被重写，重载
       * @return
       */
      public static final LazyInnerClassSingleton getInstance(){
          //先加载静态内部类，再返回结果
          return LazyLoader.LAZY;
      }
  
      /**
       * 内部类，只有在被调用的时候才会加载，加载完成后才供调用者使用
       */
      private static class LazyLoader {
          private static final LazyInnerClassSingleton LAZY=new LazyInnerClassSingleton();
      }
  }
  2.3、注册式单例：又称为登记式单例，将每一个实例都登记到某一个地方，使用唯一的标识获取实例，注册式单例有两种写法，一种是容器缓存，一种是枚举登记，枚举
  登记优点是线程安全（饿汉式单例），且反射和序列化都无法破坏单例，缺点是和饿汉模式一样，若是没有被调用，浪费了内存空间。容器缓存适用于创建实例较多的情况，
  便于管理，但是非线程安全，加锁会降低执行效率。
  
  
3.破坏单例的方式有哪些?
  3.1、反射破坏单例，通过暴力初始化，可以破坏单例，解决办法是在私有构造中添加一些限制，一旦出现多次重复创建，直接抛出异常。
  3.2、序列化反序列化破坏单例，序列化将代码写到磁盘，反序列化将磁盘中的代码读取到内存，读取的时候会新建一个实例，破坏了单例，解决办法是在单例类中添加readResolve()
  方法，在该方法中直接将单例对象返回，原因是底层代码判断只要有无参构造就会实例化，判断无参构造后又调用了hasReadResolveMethod()方法，若readResolve方法存在，则
  调用invokeReadResolve()方法，在invokeReadResolve()方法中反射调用了readResolve()方法，我们在readResolve()返回实例，解决了单例破坏的问题。
  
4.内部类的执行逻辑？
  4.1、内部类的外部类加载的时候，内部类是没有加载的，只有在调用内部类的时候，内部类才会加载，且内部类一定是加载完成后再参与调用